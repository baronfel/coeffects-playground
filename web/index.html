<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width" />
  <title>Coeffects</title>
  <script src="//code.jquery.com/jquery-2.1.4.min.js"></script>
  <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha256-KXn5puMvxCw+dAYznun+drMdG1IFl3agK0p/pqT9KAo= sha512-2e8qq0ETcfWRI4HJBzQiA3UoyFk6tbNyG+qSaIBZLyW9Xf3sWZHN/lxe9fTh1U45DpPf07yj94KsUHHWe4Yk1A==" crossorigin="anonymous"></script>
  <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-7s5uDGW3AHqw6xtJmNNtr+OBRJUlgkNJEo78P4b0yRw= sha512-nNo+yCHEyn0smMxSswnf/OnX6/KwJuZTlNZBjauKhTK0c+zT+q5JOCx0UFhXQ6rJR9jg6Es8gPuD2uZcYDLqSw==" crossorigin="anonymous">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
  <script src='//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
  <script src="smoothie.js"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({ TeX: { extensions: ["color.js"] }});
  </script>  
  <link rel="stylesheet" href="style.css" />
  <script src="interactive.js" type="text/javascript"></script>
  <script src="tips.js" type="text/javascript"></script>
  <script src="script.js" type="text/javascript"></script>
</head>
<body>
  <div id="header">
  <div class="container">
    <h1>Coeffects: <em>Context-aware programming languages</em></h1>
  </div>
  </div>
  <nav class="navbar" data-spy="affix" data-offset-top="100">
    <div class="container">
      <div class="navbar-header">
       <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#nb" aria-expanded="false">
         <span class="sr-only">Toggle navigation</span>
         <span class="icon-bar"></span>
         <span class="icon-bar"></span>
         <span class="icon-bar"></span>
       </button>
      </div>
      <div class="collapse navbar-collapse" id="nb">
       <ul class="nav navbar-nav">
         <li><a href="#">Home</a></li>
         <li><a href="#">About</a></li>
         <li><a href="#">Demos</a></li>
       </ul>
       <ul class="nav navbar-nav navbar-right ia-ui-menu">
         <li class="ia-choice" data-ia-key="ch1" data-ia-ui-kind="box" data-ia-show="" data-ia-hide="intro-motivation intro-theory langs-info langs-impl-1 langs-impl-2 langs-impl-3 langs-df-1 langs-df-2 langs-df-3 langs-syntax-1"><a>Short</a></li>
         <li class="ia-choice" data-ia-key="ch2" data-ia-ui-kind="box" data-ia-show="intro-motivation langs-impl-1 langs-impl-2 langs-df-1 langs-df-3 langs-syntax-1" data-ia-hide="intro-theory langs-info langs-impl-3 langs-df-2"><a>Practice</a></li>
         <li class="ia-choice" data-ia-key="ch3" data-ia-ui-kind="box" data-ia-show="intro-theory langs-info langs-impl-3 langs-df-2" data-ia-hide="intro-motivation langs-impl-1 langs-impl-2 langs-df-1 langs-df-3 langs-syntax-1"><a>Theory</a></li>
         <li class="ia-choice" data-ia-key="ch4" data-ia-ui-kind="box" data-ia-show="intro-motivation intro-theory langs-info langs-impl-1 langs-impl-2 langs-impl-3 langs-df-1 langs-df-2 langs-df-3 langs-syntax-1" data-ia-hide=""><a>All</a></li>
       </ul>
      </div>
    </div>
  </nav>      
  
  <div class="below-nav outline">
  <div class="container">
  <div class="col-sm-7">
    
    >>>>
    
    Coeffects are [Tomas Petricek's](http://tomasp.net/academic) PhD research project.
    They are a programming language abstraction for understanding how programs access the 
    _context_ or _environment_ in which they execute.
    
    The context may be resources on your mobile phone (battery, GPS location or a network printer), 
    IoT devices in a physical neighborhood or historical stock prices. By understanding the neighborhood
    or history, a _context-aware_ programming language can catch bugs earlier and run more efficiently.
    
    This page is an interactive tutorial that shows a prototype implementation of
    coeffects in a browser. You can play with two simple context-aware languages, see how the 
    type checking works and how context-aware programs run.

    This page is also an experiment in presenting programming language research. It is a live
    environment where you can play with the theory using the power of new media, rather than 
    staring at a dead pieces of wood (although we [have those too](about.html)).
    
    <<<<
    
  </div>
  <div class="col-sm-5">
    <p>We hide some details by default to keep the tutorial shorter, but you can get them back if you want!
    </p>
  
    <div class="row ia-ui-boxes">
      <div class="col-md-6">
        <div class="ia-ui-box ia-choice" data-ia-key="ch1" data-ia-ui-kind="box" data-ia-show="" data-ia-hide="intro-motivation intro-theory langs-info langs-impl-1 langs-impl-2 langs-impl-3 langs-df-1 langs-df-2 langs-df-3 langs-syntax-1">
          <p><i class="fa fa-thumbs-up"></i><strong>Short is good!</strong> You can always come back.</p></div>
      </div>
      <div class="col-md-6">
        <div class="ia-ui-box ia-choice" data-ia-key="ch2" data-ia-ui-kind="box" data-ia-show="intro-motivation langs-impl-1 langs-impl-2 langs-df-1 langs-df-3 langs-syntax-1" data-ia-hide="intro-theory langs-info langs-impl-3 langs-df-2">
          <p><i class="fa fa-industry"></i><strong>I'm practical!</strong> Show me more examples.</p></div>
      </div>
    </div>
    <div class="row ia-ui-boxes">
      <div class="col-md-6">
        <div class="ia-ui-box ia-choice" data-ia-key="ch3" data-ia-ui-kind="box" data-ia-show="intro-theory langs-info langs-impl-3 langs-df-2" data-ia-hide="intro-motivation langs-impl-1 langs-impl-2 langs-df-1 langs-df-3 langs-syntax-1">
          <p><i class="fa fa-university"></i><strong>Love theory!</strong> Give me all the equations.</p></div>
      </div>
      <div class="col-md-6">
        <div class="ia-ui-box ia-choice" data-ia-key="ch4" data-ia-ui-kind="box" data-ia-show="intro-motivation intro-theory langs-info langs-impl-1 langs-impl-2 langs-impl-3 langs-df-1 langs-df-2 langs-df-3 langs-syntax-1" data-ia-hide="">
          <p><i class="fa fa-search"></i><strong>Show me all!</strong> Time is not an issue.</p></div>
      </div>
    </div>

  </div>
  </div>
  </div>
  
  <div style="display:none">
    \[
      \definecolor{leff}{RGB}{255,107,102}
      \definecolor{lcoeff}{RGB}{78,206,88}
      \definecolor{ltyp}{RGB}{255,202,79}
      \definecolor{lkvd}{RGB}{127,165,255}
      
      \definecolor{eff}{RGB}{177,35,43}
      \definecolor{coeff}{RGB}{35,177,53}
      \definecolor{typ}{RGB}{177,93,43}
      \definecolor{expr}{RGB}{0,0,0}
      \definecolor{kvd}{RGB}{0,45,177}
      \definecolor{num}{RGB}{43,177,93}      
    \]
  </div>
  <div class="body container">
  <div class="row">
    <div class="hidden-sm col-md-1"></div>
    <div class="col-sm-8 col-md-7 rside">
      <h2>
        <span>What problem are coeffects solving?</span><br class="hidden-sm hidden-xs hidden-md" />
        <span class="ia-choice ia-ui-circle" data-ia-undoable="true" data-ia-key="ch5" data-ia-ui-kind="light" data-ia-show="intro-motivation" data-ia-hide=""
          title="Click here to see additional &#10;practical motivation for coeffects">
          <i class="fa fa-industry"></i>
        </span>
        <span class="ia-choice ia-ui-circle" data-ia-undoable="true" data-ia-key="ch6" data-ia-ui-kind="light" data-ia-show="intro-theory" data-ia-hide=""
          title="Click here to learn more about &#10;the theory and related work">
          <i class="fa fa-university"></i>
        </span>
      </h2>

      >>>>
      Programming languages evolve to reflect the changes in the computing ecosystem.
      The next big challenge for programming language designers is building languages that 
      understand the _context in which programs run_.
        
      This challenge is not easy to see. We are so used to work with context using the current
      cumbersome methods that we do not even _see that there is an issue_. We also do not
      realize that many programming features related to _context_ can be caputred by the
      a simple _unified abstraction_. This is what coeffects do!

      <div class="ia-choice ia-ui-bar-left ia-ui-morelink" data-ia-undoable="true" data-ia-key="ch5" data-ia-ui-kind="light" data-ia-ui-prop="border-color" data-ia-show="intro-motivation" data-ia-hide="">
      
      What are some examples of context-aware computations?
      
       - In cross-platform code, the functions available on different platforms are a
         context. You can use `#if`. If you get this wrong, your code won't even compile!     
         
       - In the [Game of Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life) or 
         [weather simulations](https://en.wikipedia.org/wiki/Stencil_code), each cell in a grid
         accesses neighboring cells. But do you know how many neighbors it needs?

      </div>
      <<<<      
    </div>
  </div>
  <div class="row ia" data-ia-key="intro-motivation" data-ia-mode="long">
    <div class="col-sm-6">
      >>>>
          [hide]
          type Cache() =
            member x.Contains(key:string) = false
            member x.Get(key:string) = ""
            member x.Set(key:string, value:string) = ()
            
          open System
          let cache = new Cache()
    
      ### Cross-platformn caching

      Say you need a function that caches values in an in-memory dictionary, or using
      a local file system when it is available. Using `#if`, you can write:

          let readFromCache key f =
          
            // Read value from memory or disk
            if cache.Contains(key) then 
              cache.Get(key)
          #if LOCAL_FILE_SYSTEM
            elif File.Exists(key) then 
              File.ReadAllText(key)              
          #endif
          
            // Calculate and cache the value
            else
              let result = f()
              cache.Set(key, result)
          #if LOCAL_FILE_SYSTEM
              File.WriteAllText(key, result)
          #endif    
              result

      
      You could refactor the code to make it less ugly, but the issue will not go away.
      As you need to target more and more platforms, the combinations of `#if` flags grow
      exponentially and it is hard to know that all configurations even compile.
      
      Ideally, the programming language would understand which functions need what capabilities
      and it would automatically check on which platforms can your code run.      
      <<<<
    </div>
    <div class="col-sm-6">
      
      >>>>
          [hide]
          let input = [| 0 |]
          let output = [| 0 |]
          let cursor = 0
          
      ### Stencil computations
      
      In stencil computations, we calcualte value for each element of a grid or mesh based on its
      neighborhood. This is useful in simulations in fluid dynamics or weather modelling. 
      
      A simple example is Conway's Game of Life or other cellural automata. The following example
      implements the [rule 110](https://en.wikipedia.org/wiki/Rule_110) (`arr.[x]` accesses x<sup>th</sup>
      element of the array and `cursor` is the current position):

          let sum = input.[cursor-1] + 
            input.[cursor] + input.[cursor+1] 
            
          if sum = 2 || (sum = 1 && 
              input.[cursor-1] = 0)
            then output.[cursor] <- 1 
            else output.[cursor] <- 0 

      <table id='rule110' style="margin:-10px 20px 5px 20px; overflow:hidden;"></table>
      <div style="text-align:right;"><button id='rule110btn' class="btn" style="width:60px;margin:0px 20px 5px 0px">Run</button></div>
      
      This automata looks at one item on the left and one item on the right. Knowing this is important
      for correctly handling border conditions. If the compiler knew the access pattern, it could
      check this and it could also pre-allocate the necessary space and produce more efficient code,
      especially when compiling for a GPU.
      <<<<
      
    </div>
  </div>
  <div class="row new-section">
    <div class="col-md-7">
      <div class="ia-slides" id="judgement-slides">
      >>>>
      <div class="slide">
      
      ### Simple type systems
      
      To understand effects and coeffects, let's look at how their type systems work. 
      In langauges like F#, the following holds:
      
      $$$
      x:{\color{ltyp} \text{int}},~ y:{\color{ltyp} \text{int}} \vdash x+y : {\color{ltyp} \text{int}}
      
      This says that in a _context_ with variablex $x$ and $y$ of type $\color{ltyp}\text{int}$, the
      type of expression $x+y$ is also $\color{ltyp}\text{int}$. The context on the left of $\vdash$
      is important! If the variables $x$ and $y$ had incompatible types, this would not be well-typed!
            
      </div><div class="slide">
      
      ### Effect systems
      
      The type of expressions with side-effect is $\color{ltyp}\text{unit}$, which does not tell 
      us very much! Effect systems add one more component:
      
      $$$
      hello : {\color{ltyp} \text{string}} \vdash {\color{lkvd} \text{print}}~hello : {\color{ltyp} \text{unit}} {\scriptsize \;\&\;} {\color{leff} \{ \text{io} \} }
      
      Effect systems understand built-in functions like ${\color{lkvd} \text{print}}$ and they infer
      not just the type of an expression, but also an _effect_. Here ${\color{leff} \{ \text{io} \} }$
      means that the expression requires I/O access but not, for example, direct access to mutable memory.
      
      </div><div class="slide">
      
      ### Coeffect systems
      
      Coeffects add an annotation to the _context_ of an expression. For example, checking whether we
      missed a deadline returns $\color{ltyp} \text{bool}$ and requires a set of resources
      $\color{lcoeff} \{ \text{clock} \}$:
      
      $$$
      deadline : {\color{ltyp} \text{time}} {\scriptsize \;@\;} {\color{lcoeff} \{ \text{clock} \} } 
        \vdash {\color{lkvd} \text{now}} \geq deadline : {\color{ltyp} \text{bool}}
      
      Coeffects can do more though. We can add requirements to the whole context (as here), but 
      also to individual variables. We will do this later for checking dataflow computations.
      
      </div><div class="slide">
      
      ### Type systems side-by-side
      
      <table>
      <tr><td style="padding-right:20px">
        
      $$$
      \Gamma \vdash e : {\color{ltyp} \tau}

      </td><td>
        
      In standard type systems, we say that given variables in $\Gamma$, 
      an expression $e$ has a type ${\color{ltyp} \tau}$:
      
      </td></tr><tr><td style="padding-right:20px">
      
      $$$
      \Gamma \vdash e : {\color{ltyp} \tau} {\scriptsize \;\&\;} {\color{leff} r}
      
      </td><td>
      
      Effect systems add annotation to the result. Given variables in $\Gamma$, 
      an expression $e$ has a type ${\color{ltyp} \tau}$ and an _effect_ ${\color{leff} r}$:
      
      </td></tr><tr><td style="padding-right:20px">
    
      $$$
      \Gamma {\scriptsize \;@\;} {\color{lcoeff} r} \vdash e : {\color{ltyp} \tau}
      
      </td><td>
    
      Coeffect systems say more about the context. Given a variables in $\Gamma$
      and additioonal context ${\color{lcoeff} r}$ an expression $e$ has a type ${\color{ltyp} \tau}$:
      
      </td></tr></table>      
      </div>
      <<<<
      </div>  
    </div>
    <div class="col-md-5">
      >>>>
      <div class="ia-choice ia-ui-bar-right ia-ui-morelink" data-ia-undoable="true" data-ia-key="ch6" data-ia-ui-kind="light" data-ia-ui-prop="border-color" data-ia-show="intro-theory" data-ia-hide="">

      _Coeffects_ are the <abbr title="In the category-theoretial sense, but there are interesting subtle issues!">dual</abbr> 
      of _effects_. Effects represent what your program _does to the world_ while coeffects track 
      what your program _requires from the world_. 
      
      Writing to a console is an I/O effect. You modify the world. If your program reads the 
      current time, it is a coeffect. The environment has to provide a clock. 
      
      One difference between effects and coeffects is that coeffects can be satisfied in multiple 
      different ways. If the device visitng your client/server application does not have clock, 
      the coeffect can use clock available from the server.
      
      You can see the duality of effects and coeffects when you look at their _type systems_, but
      it also affects the _semantics_. That is, how context-aware programs run.
      
      </div>
      <<<<
    </div>
  </div>
  
  <div class="row ia" data-ia-key="intro-theory" data-ia-mode="long">
    >>>>    
    <div class="col-sm-6 col-md-4">
      
    ### Lambda abstraction
      
    In effect systems, the effects of function body are always <abbr title="Ross Tate (2013) calls 
    this producer effect systems.">delayed</abbr>. A printing inside function body will happen when the 
    function is executed. Coeffects are different. 
    
    Say we have a function that requires a clock. We
    construct it on the server and then send it to the client. The clock can come from the declaration
    side (server) or from the call side (client). Scroll to [coeffect type systems](#typesystem) 
    for the details.
  
    </div><div class="col-sm-6 col-md-4">
      
    ### Structural coeffects
    
    Coeffects can be associated with the whole context, but they can also talk about 
    _individual variables_. For example, we can track whether a variable is used (live) 
    or not (dead):
    
    $$$
    x : {\color{typ} \text{int}}, y : {\color{typ} \text{int}} {\scriptsize \;@\;} 
      {\color{coeff} \langle \sf L, \sf D \rangle } 
      \vdash x : {\color{typ} \text{int}}
    
    Here, the coeffect is a _vector_ of annotations and we see the $x$ is live but 
    $y$ is dead. The compiler can then eliminate dead variables!

    </div><div class="col-sm-12 col-md-4">
      
    ### Comonadic semantics
    
    Effectful computations can be <abbr title="This famous result is due to Moggi (1991)">modelled using monads</abbr>.
    A function $\tau_1 \rightarrow \tau_2$ with side effects becomes $\tau_1 \rightarrow {\color{eff} M}\tau_2$ 
    where the monad ${\color{eff} M}$ tracks the additional effects as part of the result.
    
    Context-aware computations can be similarly <abbr title="This has first been discovered by Uustalu and 
      Vene (2008)">modelled using comonads</abbr>. A function that requires additional context becomes
    ${\color{coeff} C} \tau_1 \rightarrow \tau_2$ where the comonad ${\color{coeff} C}$ captures the
    additional context.
    
    </div>
    <<<<
  </div>  
  
  <div class="row new-section">
    <div class="hidden-sm col-md-3"></div>
    <div class="col-sm-12 col-md-9 lside">  
    <h2>
      <span>Two coeffect languages</span><br class="hidden-sm hidden-xs hidden-md" />
      <span class="ia-choice ia-ui-circle" data-ia-undoable="true" data-ia-key="ch7" data-ia-ui-kind="light" data-ia-show="langs-info" data-ia-hide=""
        title="Click here to learn more about &#10;how the coeffect playground works">
        <i class="fa fa-search"></i>
      </span>
    </h2>
    >>>>
    
    <div class="row"><div class="col-sm-6">      
    <h3 style="margin-top:0px">Implicit parameters</h3>
    
    Here, you can play with two simple coeffect languages. A language with 
    <abbr title="This is inspired by Haskell's implicit parameters introduced by Lewis et al. (2000)">implicit 
    parameters</abbr> shows how coeffects track additional contextual information such as
    available resources (GPS, network printer) or available device features (file system, network). 
    In our small demo, resources are written as `?size`.
    
    </div><div class="col-sm-6">
    <h3 style="margin-top:0px">Dataflow language</h3>
    
    The second demo is a simple 
    <abbr title="The demo is inspired by the synchronous dataflow language Lustre introduced by Halbwachs et al. (1991)">
    dataflow language</abbr> where all variables represent _streams_ of values
    and you can access previous value using the `prev` keyword. For example `(x + prev x) / 2`
    calculates the average over the current and previous value. Here, coeffects track how many
    past values you need.
          
    </div></div>
    <div class="ia-choice ia-ui-bar-right" data-ia-undoable="true" data-ia-key="ch7" data-ia-ui-kind="light" data-ia-ui-prop="border-color" data-ia-show="langs-info" data-ia-hide="">
    <div class="row callout" id="playground-callout">
    <div class="col-sm-12"><h3 style="margin:5px 0px 15px 15px;">How does the coeffect playground work?</h3></div>
    <div class="col-sm-4" style="padding-left:30px">
    <i class="fa fa-check-circle" style="color:#FB8072"></i> 
    
    **You choose a snippet. Coeffect system checks it.**
    
    <p class="ia" data-ia-key="langs-info" data-ia-mode="long">
    The system infers the names of the required implicit parameters
    or the required number of past values in the input streams.</p>
    
    </div><div class="col-sm-4" style="padding-left:30px">
    <i class="fa fa-arrow-circle-right" style="color:#80B1D3"></i> 
 
    **Behind the scenes, the snippet is <abbr title="Translated into a plain language.">desugared</abbr>.**
    
    <p class="ia" data-ia-key="langs-info" data-ia-mode="long">
    In the translated code, implicit parameters are passed around as 
    dictionaries and streams become lists of values.</p>
    
    </div><div class="col-sm-4" style="padding-left:30px">      
    <i class="fa fa-play-circle" style="color:#FDB462"></i> 

    **Enter inputs and run the code. It cannot fail!**
    
    <p class="ia" data-ia-key="langs-info" data-ia-mode="long">
    The coeffect type system guarantees that program accesses only the values that
    it asks for and so the program runs correctly!</p>
    
    </div></div></div>    
    <<<<    
    </div>
  </div>
  

  <div class="row new-section">
    <div class="col-md-6"></div>
    <div class="col-md-6">
      <h2>Implicit parameters
        <span style="margin-left:30px;position:relative;top:-5px">
          <span class="ia-choice ia-ui-circle" data-ia-undoable="true" data-ia-key="langs-syntax-1" data-ia-ui-kind="light" data-ia-show="langs-syntax-1" data-ia-hide=""
            title="Click here to expand &#10;documentation on syntax">
            <i class="fa fa-search"></i>
          </span>
          <span class="ia-choice ia-ui-circle" data-ia-undoable="true" data-ia-key="langs-impl-1" data-ia-ui-kind="light" data-ia-show="langs-impl-1" data-ia-hide=""
            title="Click here for more detailed &#10;version of the sample explanations">
            <i class="fa fa-industry"></i>
          </span>
          <span class="ia-choice ia-ui-circle" data-ia-undoable="true" data-ia-key="langs-impl-2" data-ia-ui-kind="light" data-ia-show="langs-impl-2" data-ia-hide=""
            title="Click here for more detailed &#10;version of the sample explanations">
            <i class="fa fa-industry"></i>
          </span>      
          <span class="ia-choice ia-ui-circle" data-ia-undoable="true" data-ia-key="langs-impl-3" data-ia-ui-kind="light" data-ia-show="langs-impl-3" data-ia-hide=""
            title="Click here for more detailed &#10;version of the sample explanations">
            <i class="fa fa-institution"></i>
          </span>      
        </span>      
      </h2>
    </div>
  </div>
  <div class="row coeff-demo" data-coeff-mode="flat" data-coeff-kind="implicit" id="impl1">
    <div class="col-md-6">
      <div class="callout coeffect-playground" style="padding:30px;margin:0px 10px 30px 0px;">
        <p>Choose a sample from the tutorial or write your own snippet using 
          <code>?param</code> to access an implicit parameter value!</p>

        <textarea class="form-control" id="impl1-input">?fst + ?snd</textarea>
        <button class="btn btn-success" id="impl1-btn"><i class="fa fa-check"></i>Check snippet</button>
        <script>$(function() { $("#impl1-btn").trigger("click"); });</script>
        
        <p id="impl1-error" style="clear:both;"></p>
        <div id="impl1-no-error">
          <p style="clear:both;">The program is well-typed. The type system reports the following 
            type and coeffect information:</p>
          
          <p id="impl1-judgement" data-tex-color-prefix="l"></p>
          <p id="impl1-judgement-temp" style="display:none"></p>
          
          <p id="impl1-playground-no-ui">The context of the expression requires no implicit parameters. You can see the result below.</p>
          <p id="impl1-playground-ui">The expression requires some implicit parameter values. You can set their values here:</p>
          <div id="impl1-playground">
          </div>
        </div>
        <div style="clear:both"></div>
      </div>
      >>>>
      <div class="ia-choice ia-ui-bar-left ia-ui-morelink" data-ia-undoable="true" data-ia-key="langs-syntax-1" 
        data-ia-ui-kind="light" data-ia-ui-prop="border-color" data-ia-show="langs-syntax-1" data-ia-hide="">
      
      Supported syntax in the coeffect language includes numbers and operators, variables and
      implicit parameters, let binding, function values and application.
      
      </div>
      <div class="ia" data-ia-key="langs-syntax-1" data-ia-mode="long">
            
       - Numbers `42`, variables `foo` and implicit parameters `?foo`
       - Numerical operators `+`, `-`, `*`, `/` and `^`
       - Let binding `let x = e1 in e2` where `in` is required
       - Application `e1 e2` and functions `fun x -> e`
       - Define a named function using `let foo x = x + 1 in ...`
       - Curring is supported. For example: `fun x y -> x + y`
      
      The syntax is ML and F#-inspired. Unlike in F#, it is not 
      indentation-sensitive and so you need the `in` keyword in each
      `let` binding.       
      </div>
      <<<<      
    </div>
    <div class="col-md-6" data-coeff-editor="impl1">
      >>>>
      <div class="ia-choice ia-ui-bar-right ia-ui-morelink" data-ia-undoable="true" data-ia-key="langs-impl-1" 
        data-ia-ui-kind="light" data-ia-ui-prop="border-color" data-ia-show="langs-impl-1" data-ia-hide="">
      
      Implicit parameters are the simplest example of coeffects. In our first langauge, 
      you can use `?foo` to access a value that has to be provided by the environment.
      
      </div>
          
          [lang=coeffects-flat-impl]
          ?fst + ?snd
      
      <div class="ia" data-ia-key="langs-impl-1" data-ia-mode="long">
      
      When you load the snippet in the editor, you will need to enter values for `?fst` and `?snd`
      before you can run the code. This is because the two values are the required _coeffects_ of
      the expression. We use numbers, but the same mechanism would work for resources like GPS 
      sensors or printers.
      
      </div>

      ### Static and dynamic scoping
        
      <div class="ia-choice ia-ui-bar-right ia-ui-morelink" data-ia-undoable="true" data-ia-key="langs-impl-2" 
        data-ia-ui-kind="light" data-ia-ui-prop="border-color" data-ia-show="langs-impl-2" data-ia-hide="">
      
      When you create a function, it can read parameters that are available in the 
      current scope (this is [lexical scoping](https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scoping)),
      but it can also read parameters that are available when the function is called (this is
      [dynamic scoping](https://en.wikipedia.org/wiki/Scope_(computer_science)#Dynamic_scoping)).

      </div>
      <div class="ia" data-ia-key="langs-impl-2" data-ia-mode="long">

      Dynamic scoping is useful when you want to add a parameter to a function in a deeply
      nested chain of calls. With implicit parameters, you do not have to explicitly pass it 
      around in each function. For example:

      </div>
      
          [lang=coeffects-flat-impl]
          let dyn = 
            (fun snd -> ?fst + snd) in
          let ?fst = 10 in dyn ?other

      <div class="ia" data-ia-key="langs-impl-2" data-ia-mode="long">
      
      The function `dyn` uses a parameter `?fst`. We set the parameter value when we _call_ the 
      function. The coeffect system tracks the required implicit parameters and it won't allow calling the
      function if we do not provide a value. You can see (in a tooltip for `dyn`) that the type of 
      the function is `num -{ ?fst:num }-> num`. 
      
      However, coeffects also support lexical scoping and capture parameters that are already in scope:

      </div>
      
          [lang=coeffects-flat-impl]
          let lex = 
            let ?fst = 10 in
            (fun snd -> ?fst + snd) in
          lex ?other

      <div class="ia" data-ia-key="langs-impl-2" data-ia-mode="long">
  
      The implicit parameter `?fst` is in scope when `lex` is defined and so the function
      does not require any implicit parameters. Its type is `num -> num`. 
      
      This is where coeffects differ from effects and monads! If we were using the Reader monad,
      we would get a function that requires `?fst`. In other words, monads support only 
      dynamic scoping, but not lexical scoping.
      
      </div>
      
      ### Resolving ambiguity
        
      <div class="ia-choice ia-ui-bar-right ia-ui-morelink" data-ia-undoable="true" data-ia-key="langs-impl-3" 
        data-ia-ui-kind="light" data-ia-ui-prop="border-color" data-ia-show="langs-impl-3" data-ia-hide="">
      
      A fun question is, what happens when the parameter `?fst` is available in both the 
      lexical scope (when defining function) and the dynamic scope (when calling the function).
      Run the code sample to see whether `?fst` becomes 100 or 200!

      </div>
      
          [lang=coeffects-flat-impl]
          let both = 
            let ?fst = 100 in
            (fun trd -> ?fst + ?snd + trd) in
          let ?fst = 200 in both 1

      <div class="ia" data-ia-key="langs-impl-3" data-ia-mode="long">
        
      The type of `both` is `num -{ ?snd:num }-> num`, which suggests that parameters available in 
      the lexical scope are always captured (this is the case of `?fst` here). In other words, 
      the _lambda abstraction_ rule in our type system splits the coeffects of the body so that only 
      requirements that cannot be satisfied from the current lexical scope (when defining the 
      function) are delayed and are required when calling the function.
      
      For more information about how this works, scroll down to the [type system section](#typesystem),
      which shows the typing derivations for these examples.

      </div>      
      <<<<
      
    </div>
  </div>
  <div class="row new-section">
    <div class="col-md-6">
      <h2>Dataflow computations
        <span style="margin-left:30px;position:relative;top:-5px">
          <span class="ia-choice ia-ui-circle" data-ia-undoable="true" data-ia-key="langs-df-1" data-ia-ui-kind="light" data-ia-show="langs-df-1" data-ia-hide=""
            title="Click here for more detailed &#10;version of the sample explanations">
            <i class="fa fa-industry"></i>
          </span>
          <span class="ia-choice ia-ui-circle" data-ia-undoable="true" data-ia-key="langs-df-2" data-ia-ui-kind="light" data-ia-show="langs-df-2" data-ia-hide=""
            title="Click here for more detailed &#10;version of the sample explanations">
            <i class="fa fa-institution"></i>
          </span>      
          <span class="ia-choice ia-ui-circle" data-ia-undoable="true" data-ia-key="langs-df-3" data-ia-ui-kind="light" data-ia-show="langs-df-3" data-ia-hide=""
            title="Click here for more detailed &#10;version of the sample explanations">
            <i class="fa fa-industry"></i>
          </span>      
        </span>      
      </h2>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6" data-coeff-editor="df1">
      >>>>
      <div class="ia-choice ia-ui-bar-left ia-ui-morelink" data-ia-undoable="true" data-ia-key="langs-df-1" 
        data-ia-ui-kind="light" data-ia-ui-prop="border-color" data-ia-show="langs-df-1" data-ia-hide="">
      
      In dataflow languages, each expression denotes a _stream_ of values. The streams can be low-level
      like hardware signals or high-level such as mouse position in modern reactive programming. In our
      langauge, you can use the `prev` keyword to access the previous value of a stream. Coeffects 
      infer how many past values a function may access.
      
      </div>
            
          [lang=coeffects-structural-df]
          fun n -> (n + prev n) / 2
      
      <div class="ia" data-ia-key="langs-df-1" data-ia-mode="long">
      
      This function calculates the average between the _current_ and the _previous_ value. The
      type of the function is `num -{ 1 }-> num` denoting that it needs one last value. Try
      removing `prev` altogether or looking further into the history using `prev (prev n)` to see 
      how the number of required past values changes!
      
      </div>
      <div class="coeff-demo" data-coeff-editor="df1fl" data-coeff-mode="flat" data-coeff-kind="dataflow" id="df1fl">

      ### Structural and flat coeffects
      
      <div class="ia-choice ia-ui-bar-left ia-ui-morelink" data-ia-undoable="true" data-ia-key="langs-df-2" 
        data-ia-ui-kind="light" data-ia-ui-prop="border-color" data-ia-show="langs-df-2" data-ia-hide="">
            
      Coeffects can track information in two ways. _Flat_ coeffects track one piece of information 
      for the whole expression while _structural_ coeffects have one piece of information for each
      variable. Implicit parameters are flat, but dataflow coeffects can work in both ways.

      The following snippet is checked using the flat coeffect system. The type of `flat` says
      that we need one past value of both `x` and `y`:
      
      </div>
      <div class="pre-edit" id="switch1">
      <a id="df1fl-btn" style="display:none; right:95px"><i class="fa fa-check-square-o"></i>check</a>
      <a onclick="$('#switch1 pre, #switch1 textarea, #df1fl-btn').toggle()"><i class="fa fa-pencil-square-o"></i> edit</a>
        
          [lang=coeffects-flat-df-autoload]
          let flat x y = x + prev y in
          flat
      
      <div class="prelike">
      <textarea class="prelike" id="df1fl-input" style="height:80px;display:none">let flat x y = x + prev y in
      flat</textarea></div>
      </div>
      <div style="margin-top:-15px">
      <p id="df1fl-judgement" style="margin-right:40px" data-tex-color-prefix=""></p>
      <p id="df1fl-judgement-temp" style="display:none"></p></div>
      <div class="ia" data-ia-key="langs-df-2" data-ia-mode="long">
      
      When checking the body `x + prev y`, the flat system infers that the required number of past
      values is 1. There is just one number for the whole expression, so the system does not capture
      the fact that we're only accessing past value of the variable `y`. Try changing the body to
      `x + y` or to `prev (x + y)` and see how the inferred type changes. Click "edit" and then
      "check" to type-check the code snippet.
      
      </div>
      </div>
      <div class="coeff-demo" data-coeff-editor="df1st" data-coeff-mode="structural" data-coeff-kind="dataflow" id="df1st">
      <div class="ia-choice ia-ui-bar-left" data-ia-undoable="true" data-ia-key="langs-df-2" 
        data-ia-ui-kind="light" data-ia-ui-prop="border-color" data-ia-show="langs-df-2" data-ia-hide="">

      The following snippet is checked using the structural coeffect system. The type of `struct`
      says that we need one past value of `y` but only the current value of `x`:

      </div>
      <div class="pre-edit" id="switch2">
      <a id="df1st-btn" style="display:none; right:95px"><i class="fa fa-check-square-o"></i>check</a>
      <a onclick="$('#switch2 pre, #switch2 textarea, #df1st-btn').toggle()"><i class="fa fa-pencil-square-o"></i> edit</a>
        
          [lang=coeffects-struct-df-autoload]
          let struct x y = x + prev y in
          struct
      
      <div class="prelike">
      <textarea class="prelike" id="df1st-input" style="height:80px;display:none">let struct x y = x + prev y in
      struct</textarea></div>
      </div>
      <div style="margin-top:-15px">
      <p id="df1st-judgement" style="margin-right:40px" data-tex-color-prefix=""></p>
      <p id="df1st-judgement-temp" style="display:none"></p></div>      
      <div class="ia" data-ia-key="langs-df-2" data-ia-mode="long">
      
      The structural system keeps one annotation for each variable. When checking the body `x + prev y`,
      it infers that we access the current value of `x` and one past value of `y`. This is
      reflected in the type of the function. Try changing the body in the same way as previously
      and see how the type of the function changes!
      
      </div>
      
      The flat system for tracking number of past values in dataflow languages is actually an 
      instance of the same _coeffect calculus_ as the one for tracking implicit parameters. 
      The structural system is more sophisticated, because it needs to keep track of 
      individual variables. Aside from dataflow, it can also capture 
      <abbr title="A variable is dead if it is never accessed and an optimizing &#10;compiler can eliminate dead variables.">variable liveness</abbr>.
      
      <<<<  
      </div>      
    </div>
    <div class="col-md-6 coeff-demo" data-coeff-mode="structural" data-coeff-kind="dataflow" id="df1">
      <div class="callout coeffect-playground" style="padding:30px;margin:0px 0px 30px 10px;">
        >>>>
        Experiment with dataflow programming here! You can use the same core langauge 
        as earlier; `prev e` accesses the previous value of `e` and you can
        nest them and write `prev (prev e)`.
        <<<<

        <textarea class="form-control" id="df1-input">fun n -> (n + prev n) / 2</textarea>
        <button class="btn btn-success" id="df1-btn"><i class="fa fa-check"></i>Check snippet</button>
        <script>$(function() { $("#df1-btn").trigger("click"); });</script>
        
        <p id="df1-error" style="clear:both;"></p>
        <div id="df1-no-error">
          <p style="clear:both;">The program is well-typed. The type system reports the following 
            type and coeffect information:</p>
          
          <p id="df1-judgement" data-tex-color-prefix="l"></p>
          <p id="df1-judgement-temp" style="display:none"></p>
          
          <p id="df1-playground-no-ui">The expression was not a function and you can see the result below.
            For more fun, write a function like <code>fun x -> prev x</code>!</p>
          <p id="df1-playground-ui">The function requires some input streams. You can set their current and historical values here:</p>
          <div id="df1-playground">
          </div>
          
        </div>
        <div style="clear:both"></div>
      </div>
    </div>    
  </div>  
  <div class="row">
    <div class="col-md-6" data-coeff-editor="dfmouse">
      >>>>
      ### Interactive dataflow programs
      
      <div class="ia-choice ia-ui-bar-left ia-ui-morelink" data-ia-undoable="true" data-ia-key="langs-df-3" 
        data-ia-ui-kind="light" data-ia-ui-prop="border-color" data-ia-show="langs-df-3" data-ia-hide="">
      
      Dataflow programming can be nciely used to handle user inputs. You can try it here
      by writing programs that compute value based on current and past X and Y coordinates
      of a mouse or finger. Click on the "load" button of the snippet and start moving your mouse 
      pointer or touching in the dedicated box. The X and Y coordinates will be passed as inputs 
      and you'll see the result in a chart. 
      
      The `oldx` function reads an old value of the X coordinate. Move the cursor
      from left to right and back and see how the chart with the result is a delayed version 
      of the input:

      </div>
    
          [lang=coeffects-struct-df]
          let oldx x y = 
            let prev4 v = prev prev prev prev v in
            prev4 (prev4 (prev4 x)) in
          oldx
          
      <div class="ia" data-ia-key="langs-df-3" data-ia-mode="long">

      To avoid nesting the `prev` construct 12 times, we define a function `prev4` that
      returns the 4th past value. When we then call `prev4 (prev4 x)` we are then accessing
      the 8th past value. The chart updates 20 times per second, so you should see about 
      500ms delay.

      </div>
      <div class="ia-choice ia-ui-bar-left ia-ui-morelink" data-ia-undoable="true" data-ia-key="langs-df-3" 
        data-ia-ui-kind="light" data-ia-ui-prop="border-color" data-ia-show="langs-df-3" data-ia-hide="">
      
      We can also calculate an average over last few values to implement smoothing. Here,
      we average 12 values (the current one and 11 past):

      </div>

          [lang=coeffects-struct-df]
          let smooth x y = 
            let sum4 v = v + prev (v + prev (v + prev v)) in
            let prev4 v = prev prev prev prev v in
            let s1 = sum4 x + sum4 (prev4 x) in
            let s2 = sum4 (prev4 (prev4 x)) in
            (s1 + s2) / 12 in
          smooth
            
      <div class="ia" data-ia-key="langs-df-3" data-ia-mode="long">
        
      Just like above, we use helper functions to make the code shorter. The `sum4` function
      adds the current value and 3 previous and `prev4` returns 4th past value of an argument.
      We then sum 12 values in chunks by adding `sum4 x`, `sum4 (prev4 x)` and `sum4 (prev4 (prev4 x))`.

      </div>
      <div class="ia-choice ia-ui-bar-left ia-ui-morelink" data-ia-undoable="true" data-ia-key="langs-df-3" 
        data-ia-ui-kind="light" data-ia-ui-prop="border-color" data-ia-show="langs-df-3" data-ia-hide="">
      
      In the last example, the resulting chart will show how quickly you are moving your mouse
      or finger over the box:

      </div>
        
          [lang=coeffects-struct-df]
          let speed x y = 
            let dx = x - prev x in
            let dy = y - prev y in
            dx * dx + dy * dy
          in speed
      
      <div class="ia" data-ia-key="langs-df-3" data-ia-mode="long">
        
      We use `x - prev x` to calculate the difference between the current and previous value,
      then we square it and add the speeds of X and Y moves. You should see higher spikes when
      you move your mose faster and smaller spikes when you move it slowly.
      
      </div>
      <<<<
    </div>
    <div class="col-md-6">
      <div class="callout coeff-demo coeffect-playground" style="padding:30px;margin:60px 0px 30px 10px;"
          data-coeff-mode="structural" data-coeff-kind="dataflow" id="dfmouse">
        <p>Write simple dataflow computations that produce a value based on the current and previous
          X and Y coordinates.</p>

        <textarea class="form-control" id="dfmouse-input" style="height:180px">fun x y -> x + y</textarea>
        <button class="btn btn-success" id="dfmouse-btn"><i class="fa fa-check"></i>Check snippet</button>
        <script>$(function() { $("#dfmouse-btn").trigger("click"); });</script>
        
        <p id="dfmouse-error" style="clear:both;margin-top:10px"></p>
        <div id="dfmouse-no-error" style="clear:both;margin-top:10px">          
          <p id="dfmouse-livechart-no-ui">The expression is well-typed, but it is not a function
            taking X and Y arguments, so we cannot use it for this demo. Try writing for example
            <code>fun x y -> x + y</code>.</p>
          <div id="dfmouse-livechart-ui">
            <p>All set! Start by moving mouse pointer or your finger in a circle in the box below
              and see what happens!</p>        
            <div id="dfmouse-livechart" class="live-chart">
              <div id="dfmouse-drawingspace" class="drawing-space">
                <span><i class="fa fa-mouse-pointer"></i> Move mouse or touch <br /> here to get started!</span>
              </div>
              <div class="canvas-wrapper"><canvas width="400" height="100" id="chartIn"></canvas></div>
              <div class="canvas-wrapper"><canvas width="400" height="100" id="chartOut"></canvas></div>
            </div>
          </div>
        </div>
        <div style="clear:both"></div>
      </div>
      <script> dataflowPlayground("dfmouse"); </script>
    </div>
  </div>    
  <div class="row new-section">
    <div class="hidden-sm col-md-3"></div>
    <div class="col-sm-12 col-md-7 lside no-bullets">  
      >>>>
      Why languages need coeffects?
      -----------------------------
      
      In the interactive playground above, you can write fun programs using a dataflow langauge
      with the `prev` keyword. But what do you get from using _coeffect_ system to track how
      many past values are needed? <span class="flspan" style="margin-top:50px">Most importantly, 
      coeffects give you a unified way of _thinking_ about _context-requirements_.</span>
      
       - <i class="fa fa-book"></i>
       
         **Readability.** You get code that is easier to understand. When you look at a function,
         you know whether it uses just the current value or if it needs to look at the history.
         For implicit parameters, the requirements are also immediately visible.
         
       - <i class="fa fa-bolt"></i>
       
         **Efficiencly.** By knowing how many past values we'll need, we can pre-allocate a 
         fixed-size buffer to keep the past X and Y coordinates. This means that code can run
         faster and we can also better avoid potential memory leaks.
         
       - <i class="fa fa-lock"></i>
       
         **Safety.** In case of implicit parameters, coeffects inferred which parameters are
         needed and you had to set their values _before_ running the code. This means that we
         cannot get a runtime error when a required parameter is not set!
      
      
      Modern programs need to run correctly in a larger number of increasingly diverse environments.
      Does your program need Android API level 23? GPS sensor and access to internet? Access to 
      the friends of your friends on Facebook? Or historical stock prices for 2 years?
      A language with coeffect support can check the requirements statically and give you 
      guarantees that things will run as expected. <span class="flspan-alt">Most importantly, 
      coeffects give you a unified way of _thinking_ about _context-requirements_.</span>
      
      <<<<
    </div> 
  </div>  
</div>

<div class="outline new-big-section">
  <div class="container">
  <div class="row">
    >>>>
    <div class="col-sm-5">
    <h2><a name="typesystem">Theory of coeffects</a></h2>
    
    If you got as far as here, I guess you want to know everything there is about coeffects! 
    The rest of the page shows more details about the theory about coeffects. Some parts 
    may require more detailed programming language theory background, but there are still fun
    interactive demos to help you understand it!

    The theory of coeffects consists of two _type systems_ for checking coeffects and a semantics
    that is defines the meaning of context-aware programs in terms of _translation_. We translate
    context-aware source language into a simple target language with a few _comonadically-inspired_ 
    primitives.    
    
    </div>
    <div class="col-sm-7 no-bullets" style="padding-top:40px;">
    
     - <i class="fa fa-check-circle" style="color:#FB8072"></i>
     
       **Type systems.** The type system checks how many past values does a function use 
       or which implicit parameters it accesses. Coeffects define two unified systems that
       can be specialized for individual contextual information.
       
     
     - <i class="fa fa-info-circle" style="color:#80B1D3"></i> 
     
       **Comonads.** The meaning of effectful computations can be captured using _monads_.
       A concrete monad describes a concrete kind of effect. Similarly, context-aware 
       computations can be captured using <abbr title="More precisely, they have to be indexed comonads.">comonads</abbr>. 
       One concrete comonad describes dataflow and one implicit parameters.
       
     - <i class="fa fa-chevron-circle-right" style="color:#FDB462"></i> 
     
       **Translation.** We translate the source program to a target language
       and insert calls to a few special comonadically-inspired functions. Just like _bind_
       and _return_ in Haskell's do notation, those function define how the concrete
       contextual information are passed around and used.
       
    </div>
    <<<<
  </div>  
  </div>
</div>

<div class="body container">
  <div class="row">
    <div class="col-sm-3"></div>
    <div class="col-sm-8 lside">
    <h2>
      <span>Coeffect type system</span><br class="hidden-sm hidden-xs hidden-md" />
      <span class="ia-choice ia-ui-circle" data-ia-undoable="true" data-ia-key="theory-lambda" data-ia-ui-kind="light" data-ia-show="theory-lambda" data-ia-hide=""
        title="Click here to see more details &#10;about the lambda abstraction rule." style="padding-left:5px;">
        <i class="fa fa-mortar-board"></i>
      </span>
      <span class="ia-choice ia-ui-circle" data-ia-undoable="true" data-ia-key="theory-all" data-ia-ui-kind="light" data-ia-show="theory-all" data-ia-hide=""
        title="Click here to see more details &#10;about the theory of coeffects.">
        <i class="fa fa-asterisk"></i>
      </span>
    </h2>      
    >>>>  
    <div class="ia-choice ia-ui-bar-right ia-ui-morelink" data-ia-undoable="true" data-ia-key="theory-lambda" 
      data-ia-ui-kind="light" data-ia-ui-prop="border-color" data-ia-show="theory-lambda" data-ia-hide="">
    
    Coeffect type systems are interesting in two ways. The first is the rule for lambda abstraction. 
    As the implicit parameter example illustrated, the rule needs to be flexible enough to allow
    both dynamic and lexical scoping of context requirements. The second is that coeffects can be
    attached to the whole context (_flat_ coeffects), but also to individual variables
    (_structural_ coeffects).

    To see how the lambda abstraction for coeffects work, it is best to compare the ordinary
    lambda abstraction rule, a version used by effect systems and a rule used by
    our coeffect systems.
    
    </div>  
    <div class="ia" data-ia-key="theory-lambda" data-ia-mode="long">
    
    ### Lambda abstraction      
    
    When you have an expression that prints to a console and you wrap it inside a function, 
    the printing will happen when the function is called. This is how _effects_ behave. This
    is nicely captured by Wadler and Thiemann in the
    [Marriage of effects and monads](http://dl.acm.org/citation.cfm?id=289429):
    
    > In the rule for abstraction, the effect is empty because evaluation immediately returns 
    > the function, with no side effects. The effect on the function arrow is the same as the 
    > effect for the function body, because applying the function will have the same side 
    > effects as evaluating the body. 
    
    Coeffects are different. When you _require_ an implicit parameter from the environment, it 
    can come from anywhere. You may get it (immediately) when the function is created or when 
    it is called (later). In general, coeffects place requirements both on the declaration-site
    and on the call-site.
    
    </div>
    <<<<
    </div>
  </div>

  <div class="row">
    <div class="col-sm-3"></div>
    <div class="col-sm-8">
      <div class="ia-slides" id="lambda-slides">
      >>>>
      <div class="slide" style="padding-bottom:15px;">

      ### Pure languages
      
      Given a function body $e$ of type ${\color{ltyp}\tau_2}$ and a variable $x$ of type ${\color{ltyp}\tau_1}$, the
      expression ${\color{lkvd} \text{fun}}~x \rightarrow e$ creates a function of type ${\color{ltyp}\tau_1 \rightarrow \tau_2}$.

      <div style="margin:35px 0px 35px 0px;">
        
      $$$
      \dfrac
        {\Gamma, x:{\color{ltyp} \tau_1} \vdash e : {\color{ltyp} \tau_2}}
        {\Gamma \vdash {\color{lkvd} \text{fun}}~x \rightarrow e : {\color{ltyp} \tau_1} \rightarrow {\color{ltyp} \tau_2}}

      </div>
      
      This is the standard textbook lambda abstraction rule. Now, let's look what happens for
      effect and coeffect systems!
      
      </div><div class="slide">
        
      ### Effect systems
      
      In effectful language, the body $e$ has an additional effect ${\color{leff} r}$. This could
      be writing to console, modifying memory, network communication etc.

      <div style="margin:25px 0px 25px 0px;">

      $$$
      \dfrac
        {\Gamma, x:{\color{ltyp} \tau_1} \vdash e : {\color{ltyp} \tau_2 } {\scriptsize \;\&\;} {\color{leff} r} }
        {\Gamma \vdash {\color{lkvd} \text{fun}}~x \rightarrow e : {\color{ltyp} \tau_1} \xrightarrow{~\color{leff} r~} {\color{ltyp} \tau_2} {\scriptsize \;\&\;} {\color{leff} \emptyset}}

      </div>
      
      The effect of the function creation is ${\color{leff} \emptyset}$, meaning that nothing happens
      when the function is created. All the effects ${\color{leff} r}$ are _delayed_ and attached to 
      the type of the function. They occur when the function is called.
      
      </div><div class="slide">
        
      ### Coeffect systems
      
      With coeffects, he body has additional contextual requirements, but those can
      be split between the immediate coeffects ${\color{lcoeff} r}$ (required when creating the 
      function) and delayed coeffects ${\color{lcoeff} s}$ (required when the function is called).

      <div style="margin:25px 0px 25px 0px;">

      $$$
      \dfrac
        {\Gamma, x:{\color{ltyp} \tau_1} {\scriptsize \;@\;} {\color{lcoeff} r\bullet s} \vdash e : {\color{ltyp} \tau_2 } }
        {\Gamma {\scriptsize \;@\;} {\color{lcoeff} r} \vdash {\color{lkvd} \text{fun}}~x \rightarrow e : {\color{ltyp} \tau_1} \xrightarrow{~\color{lcoeff} s~} {\color{ltyp} \tau_2}}

      </div>
      
      How ${\color{lcoeff} \bullet}$ works depends on the concrete language. For implicit parameters,
      it captures as many available parameters as possible and delays the rest.
      
      </div>
      <<<<
      </div>
    </div>
  </div>
  <div class="row">
    <div class="col-sm-3"></div>
    <div class="col-sm-8 ia-choice ia-ui-bar-right ia-ui-morelink" data-ia-undoable="true" data-ia-key="theory-all" 
      data-ia-ui-kind="light" data-ia-ui-prop="border-color" data-ia-show="theory-all" data-ia-hide="">    
      >>>>      
      There is much more that can be said about the coeffect type system. You can find a
      detailed description in the [papers on coeffects](about.html) or you can expand this
      section and read a longer summary.
      
      First, coeffect type systems are parameterized by a _coeffect algebra_. This means
      that the same system can be instantiated to track information about implicit parameters,
      dataflow or something else. Second, there is a _flat_ and _structural_ version. The
      flat one adds just one annotation for the whole context. The structural version adds
      annotations per-variable and so it is more precise for applications like dataflow.
      
      You can experiment with the type checker below. Just choose one of the systems, type
      in your program, run the type checker and explore the typing derivation!
      <<<<
    </div>
  </div>
  <div class="ia" data-ia-key="theory-all" data-ia-mode="long">
    <div class="row">
      <div class="col-sm-2"></div>
      <div class="col-sm-8">
        >>>>
        
        ### Coeffect algebra
                
        Coeffects are a general mechanism that can be instantiated to capture concrete contextual
        properties. We looked at implicit parameters and dataflow as two examples, but there are
        many other properties that can be captured as coeffects. To make this possible, the type
        system is parameterized by a _coeffect algebra_. 
        
        The $\bullet$ operation shown above is one part of the coeffect algebra. Unlike effect
        systems, which often use just a single operation - typically $\cup$ - the coeffect algebra
        is richer. There are three operations that correspond to _sequential composition_, 
        _merging of context_ (when merging information from the declaration-site and call-site
        in lambda abstraction) and _splitting of context_ (when the same context is used by
        two sub-expressions). For more details, see [the coeffect papers](about.html)!
              
        <<<<
      </div>
    </div>  
  <div class="row new-section">
    >>>>
    <div class="col-sm-6">
    <div class="callout" style="margin:10px;">
      
    ### Flat coeffect systems
    
    The second interesting aspect of coeffect systems is that the information is attached to the
    _variable context_ rather than to the _resulting type_ of an expression.
    In _flat_ coeffect systems, the coeffect is just a single annotation:
    
    $$$
    x_1\!:\!{\color{ltyp}\tau_1}, \ldots, x_n\!:\!{\color{ltyp}\tau_n} {\scriptsize \;@\;} {\color{lcoeff} r} \vdash e : {\color{ltyp} \tau}

    For implicit parameters, the annotation is a _set of implicit parameters_. Flat coeffects can 
    be used for dataflow too. In that case, the annotation is the _maximal_ number of past values 
    of any of the variables in the body.
    
    For example the expression $x + {\color{lkvd}\text{prev}}~y$ gets an annotation ${\color{lcoeff} 1}$. This is 
    correct, but not precise. We need one past value of $y$, but only the current value of $x$. 
    
    </div>
    </div>
    <div class="col-sm-6">
    <div class="callout" style="margin:10px;">
      
    ### Structural coeffect systems

    Structural coeffects solve the limited precision of the flat system when tracking
    contextual information that are attached to individual variables.
    
    Rather than adding a single annotation, _structural_ coeffects
    add a _vector of annotations_ with one annotation for each variable. We
    do not add annotations to individual variables separately to keep the same shape as in the flat
    system:
    
    $$$
    x_1\!:\!{\color{ltyp}\tau_1}, \ldots, x_n\!:\!{\color{ltyp}\tau_n} {\scriptsize \;@\;} {\color{lcoeff} \langle r_1,\ldots,r_n \rangle} \vdash e : {\color{ltyp} \tau}

    In case of dataflow, each annotation in the vector captures the number of required past values of the
    corresponding single variable. Given expression $x + {\color{lkvd}\text{prev}}~y$, the vector
    attached to $x, y$ would be ${\color{lcoeff} \langle 0, 1 \rangle}$.

    </div>  
    </div>
    <<<<
  </div>  
  <div class="row new-section">
    <div class="col-sm-2"></div>
    <div class="col-sm-8">
      >>>>
      
      The structural system needs to ensure that the vector of annotations stays in sync
      with the variables, so they treat variable context as a vector _too_. Variables can
      still be freely rearranged and duplicated, but each of those _structural_ rules
      performs a corresponding transformation on the vector of coeffect annotations.
      
      By keeping a vector of annotations, we also know the exact coeffect that should be
      associated with a function, so we no longer need the $\bullet$ operation in the
      lambda abstraction rule. Instead, function becomes annotated with the annotation 
      that belongs to the bound variable:
      
      $$$
      \dfrac
        {\Gamma, x:{\color{typ} \tau_1} {\scriptsize \;@\;} {\color{coeff} r \times \langle s \rangle} \vdash e : {\color{typ} \tau_2 } }
        {\Gamma {\scriptsize \;@\;} {\color{coeff} r} \vdash {\color{kvd} \text{fun}}~x \rightarrow e : {\color{typ} \tau_1} \xrightarrow{~\color{coeff} s~} {\color{typ} \tau_2}}
      
      Here ${\color{coeff} r \times \langle s \rangle}$ splits the vector into two parts.
      ${\color{coeff} r}$ is a vector of annotations that correspond to the variables in 
      $\Gamma$ and ${\color{coeff} \langle s \rangle}$ is a vector with just a single annotation
      that corresponds to $x$ and becomes the annotation of the function type.
      <<<<
    </div>
  </div>
  </div>
</div>

<div class="outline new-section" style="margin:30px 0px 0px 0px;overflow-x:hidden;" id="typing-slides">
<div class="container">

  <div class="row coeffect-playground">
    <div class="col-md-1"></div>
    <div class="col-md-10">      
      <div class="coeff-demo" id="tps">
        <h2>Interactive coeffect type checker</h2>
        
        <p style="margin-top:10px">Choose a coeffect language from the dropdown and load
          a sample snippet to get started.</p>        
        <div style="padding-top:5px">      
        <script>
          var samples = 
            { 'flat-implicit': "let dyn snd = ?fst + snd in\nlet ?fst = 10 in\ndyn ?other",
              'flat-dataflow': "fun x y ->\n  let avg2 = fun y -> (y + prev y) / 2 in\n  avg2 x + prev (avg2 y)",
              'structural-dataflow': "fun x y ->\n  let avg2 = fun y -> (y + prev y) / 2 in\n  avg2 x + prev (avg2 y)" };              
        </script>
        <button class="btn btn-success" style="width:20%;margin-bottom:0px;"
          onclick="$('#tps-input').val(samples[$('#tps-langchooser').val()])"><i class="fa fa-folder-open-o"></i>Open sample</button>
        <select class="form-control" id="tps-langchooser" style="width:71%; margin:0px 0px 0px 4%">
          <option value="flat-implicit">Implicit parameters (flat)</option>
          <option value="flat-dataflow">Dataflow langauge (flat)</option>
          <option value="structural-dataflow">Dataflow langauge (structural)</option>
        </select>        
        <textarea class="form-control" id="tps-input" style="font-family:inconsolata;margin-top:5px;height:150px">
let dyn snd = ?fst + snd in
let ?fst = 10 in
dyn ?other</textarea>
        </div>
        <button class="btn btn-success"  style="width:20%;" id="tps-btn"><i class="fa fa-check"></i>Check snippet</button>
        <script>$(function() { $("#tps-btn").trigger("click"); });</script>

        <p style="clear:both;padding-top:30px;margin:0px 0px 25px 0px">In the formatted code below, 
          you can see types of variables in a tooltip. Curried functions with multiple parameters 
          and function defined using <code>let</code> are expanded.</p>          
        
        <pre id="tps-longoutput" style="margin:20px 4% 0px 4%"></pre>
        
        <p style="clear:both;padding-top:30px;margin:0px 0px 25px 0px">Now explore the typing derivation. 
          Click on the judgements in the assumptions to navigate through the typing derivation.
          Compare flat and structural dataflow typing for the same program!</p>          
        
        <div style="margin:30px -3000px 0px -3000px;clear:both;">
        <p id="tps-typetree" data-current-color="#2B323A" data-navigation-color="#3D2A3F" data-tex-color-prefix="l"></p>
        <p id="tps-typetree-temp" style="display:none"></p>
        </div>

      </div>      
    </div>
    <div class="col-md-1"></div>
  </div>
</div>
</div>

<div class="body container" data-coeff-editor="trsl">
  <div class="row">
    <div class="col-sm-3"></div>
    <div class="col-sm-8 lside">
    <h2>
      <span>Comonadic translation</span><br class="hidden-sm hidden-xs hidden-md" />
      <span class="ia-choice ia-ui-circle" data-ia-undoable="true" data-ia-key="theory-lambda" data-ia-ui-kind="light" data-ia-show="theory-lambda" data-ia-hide=""
        title="Click here to see more details &#10;about the lambda abstraction rule." style="padding-left:5px;">
        <i class="fa fa-mortar-board"></i>
      </span>
      <span class="ia-choice ia-ui-circle" data-ia-undoable="true" data-ia-key="theory-all" data-ia-ui-kind="light" data-ia-show="theory-all" data-ia-hide=""
        title="Click here to see more details &#10;about the theory of coeffects.">
        <i class="fa fa-asterisk"></i>
      </span>
    </h2>      
    >>>>  
    
    Comonads
    

    <div class="ia-choice ia-ui-bar-right ia-ui-morelink" data-ia-undoable="true" data-ia-key="theory-lambda" 
      data-ia-ui-kind="light" data-ia-ui-prop="border-color" data-ia-show="theory-lambda" data-ia-hide="">
    nada
    </div>
    <<<<
    </div>
  </div>
  <div class="row">
    <div class="col-md-5">
    >>>>

        [lang=coeffects-flat-impl]
        ?foo

    another
    
        [lang=coeffects-flat-df]
        fun x -> prev x
    
    <<<<
    </div>
    <div class="col-md-7">
      <div class="callout coeffect-playground">
          <div class="coeff-demo" id="trsl">
            <p style="margin-top:10px">Choose a coeffect language from the dropdown and load
              a sample snippet to get started.</p>        
            <div style="padding-top:5px">      
            <select class="form-control" id="trsl-langchooser" style="width:71%; margin:0px 0px 0px 4%">
              <option value="flat-implicit">Implicit parameters (flat)</option>
              <option value="flat-dataflow">Dataflow langauge (flat)</option>
              <option value="structural-dataflow">Dataflow langauge (structural)</option>
            </select>        
            <textarea class="form-control" id="trsl-input" style="font-family:inconsolata;margin-top:5px;height:150px">
    let dyn snd = ?fst + snd in
    let ?fst = 10 in
    dyn ?other</textarea>
            </div>
            <button class="btn btn-success"  style="width:20%;" id="trsl-btn"><i class="fa fa-check"></i>Check snippet</button>
            <script>$(function() { $("#trsl-btn").trigger("click"); });</script>
    
            <p style="clear:both;padding-top:30px;margin:0px 0px 25px 0px">In the formatted code below, 
              you can see types of variables in a tooltip. Curried functions with multiple parameters 
              and function defined using <code>let</code> are expanded.</p>          
            
            <pre id="trsl-longoutput" style="margin:20px 4% 0px 4%"></pre>
            <pre id="trsl-transl" style="margin:20px 4% 0px 4%"></pre>
            
            <p style="clear:both;padding-top:30px;margin:0px 0px 25px 0px">Now explore the typing derivation. 
              Click on the judgements in the assumptions to navigate through the typing derivation.
              Compare flat and structural dataflow typing for the same program!</p>          
            
          </div>      
        </div>
      
    </div>
  </div>
</div>  

  
  
  <div style="min-height:300px"></div>

<div class="below-nav outline">
  <div class="container">
  <div class="col-sm-7">
  
  >>>>
  
  Thanks for reading!
  
  <<<<
  
  </div>  
  <div class="col-sm-5">
    
    moar stuff
    
  </div>  
</div>  
</body>
</html>
